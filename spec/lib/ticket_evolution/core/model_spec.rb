require 'spec_helper'

describe TicketEvolution::Model do
  let(:klass) { TicketEvolution::Model }
  let(:sample_klass) { TicketEvolution::Models::Samples }
  let(:instance) { klass.new({:id => 1, :connection => fake_connection}) }
  let(:fake_connection) { Fake.connection }

  subject { klass }

  its(:ancestors) { should include TicketEvolution::Builder }

  describe "#initialize" do
    context "when it receives an instance of connection" do
      subject { klass.new({:connection => fake_connection}) }

      it "should not error" do
        expect { subject }.to_not raise_error
      end

      it "should not respond to #connection" do
        subject.should_not respond_to :connection
      end
    end

    context "when it does not receive an instance of connection" do
      it "should raise a ConnectionNotFound error" do
        message = "#{klass.name} must receive a TicketEvolution::Connection object on initialize"
        expect { klass.new }.to raise_error TicketEvolution::ConnectionNotFound, message
      end
    end

    context "when it detects a scope in the url" do
      let(:instance) { klass.new({:connection => fake_connection, 'url' => '/clients/234/addresses/123'}) }
      let(:scope) { '/clients/234' }

      it "should set @scope" do
        instance.instance_eval{ @scope }.should == scope
      end
    end

    context "when it does not detect a scope in the url" do
      it "should not error" do
        expect { klass.new({:connection => fake_connection}) }.to_not raise_error
      end
    end
  end

  describe "#process_datum" do
    context "when dealing with a hash" do
      context "which has a :url key" do
        let(:hash) do
          {
            "url" => "/brokerages/227",
            "name" => "Night To Remember Tickets",
            "id" => "227",
            "abbreviation" => "Night to Remember"
          }
        end

        it "should create an appropriate builder object" do
          klass.new(:id => 1, :connection => fake_connection).send(
            :process_datum, hash).should be_a TicketEvolution::Brokerage
        end
      end

      context "which does not have a :url key" do
        it "should instantiate a new TicketEvolution::Datum object" do
          instance.send(:process_datum, {:one => 1}).should be_a TicketEvolution::Datum
        end
      end
    end
  end

  describe "#plural_class_name" do
    let(:plural_name) { klass.name.demodulize.pluralize.camelize }
    context "when there is a scope" do
      before { instance.instance_eval{ @scope = '/events/1' } }

      it "should include the scoped endpoint name in the pluralized version of the current class" do
        instance.plural_class_name.should == "TicketEvolution::Events::#{plural_name}"
      end
    end

    context "when there is not a scope" do
      it "should return the pluralized version of the current class" do
        instance.plural_class_name.should == "TicketEvolution::#{plural_name}"
      end
    end
  end

  describe "#plural_class" do
    let(:plural_class_name) { "TicketEvolution::Models" }
    it "call #constantize on the result of #plural_class_name" do
      instance.should_receive(:plural_class_name).and_return(plural_class_name)
      plural_class_name.should_receive(:constantize)
      instance.plural_class
    end
  end

  describe "#endpoint" do
    use_vcr_cassette "endpoints/clients/model", :record => :new_episodes

    let(:instance) { connection.clients.list(:per_page => 1).first }

    it "should return an endpoint object" do
      instance.endpoint.should be_a_kind_of TicketEvolution::Endpoint
    end

    it "should be a type of #plural_class" do
      instance.endpoint.class.should == instance.plural_class
    end

    context "when using child_endpoint" do
      it "should return a child instance" do
        instance.email_addresses_endpoint.should be_a TicketEvolution::Clients::EmailAddresses
      end
    end

    context "when this model is a child" do
      context "which was generated by a call to it's parent" do
        let(:child) { instance.email_addresses.first }
        it "should return an endpoint whose parent is another endpoint" do
          pending "adding urls to all second layer returns in the api"
          child.endpoint.parent.should be_a TicketEvolution::Clients
        end
      end

      context "which was generated by a call to the api" do
        let(:child) { instance.email_addresses.show(instance.email_addresses.first.id) }
        it "should return an endpoint whose parent is another endpoint" do
          child.endpoint.parent.should be_a TicketEvolution::Clients
        end
      end
    end

    context "when this model is not a child" do
      it "should return an endpoint whose parent is a connection" do
        instance.endpoint.parent.should be_a TicketEvolution::Connection
      end
    end
  end

  describe "#scope" do
    context "when @scope is set" do
      before { instance.instance_eval{ @scope = '/events/1' } }
      let(:scope_hash) { { :class => "TicketEvolution::Events", :id => 1 } }

      it "should return and array with class and id specified" do
        instance.scope.should == scope_hash
      end
    end

    context "when @scope is not set" do
      it "should return nil" do
        instance.scope.should == nil
      end
    end
  end

  describe "#attributes" do
    let(:params) { {"one" => 1, "two" => 2} }
    let(:expected) { HashWithIndifferentAccess.new(params) }

    it "should return the set attributes" do
      klass.new(params.merge(:connection => fake_connection)).attributes.should == expected
    end
  end

  describe "#attributes=" do
    let(:initial) { {"one" => :one, "three" => 3} }
    let(:params) { {"one" => 1, "two" => 2} }
    let(:expected) { HashWithIndifferentAccess.new(initial.merge(params)) }

    it "should set the passed attributes" do
      instance = klass.new(initial.merge(:connection => fake_connection))
      instance.attributes = params
      instance.attributes.should == expected
    end
  end

  describe "#method_missing" do
    context "when the missing class is not found" do
      it "should fall back on the default functionality" do
        expect { instance.no_objects }.to_not raise_error
      end
    end

    context "when the missing class is found" do
      before { @endpoint = instance.plural_class.new({:id => instance.id, :parent => fake_connection}) }

      it "should instantiate a new instance of the requested endpoint, passing a new instance of it's endpoint class as parent" do
        instance.plural_class.should_receive(:new).with({
          :parent => fake_connection,
          :id => instance.id
        }).and_return(@endpoint)
        sample_klass.should_receive(:new).with({:parent => @endpoint})

        instance.samples
      end
    end
  end
end
